% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_heatmap.r
\name{plot_heatmap}
\alias{plot_heatmap}
\title{Create a heatmap with tracks and dendrograms from any matrix.}
\usage{
plot_heatmap(
  mtx,
  colors = "rocket",
  top_tracks = NULL,
  left_tracks = NULL,
  label = TRUE,
  label_size = NULL,
  rescale = NULL,
  trees = TRUE,
  clust = "complete",
  dist = "euclidean",
  tree_height = NULL,
  track_height = NULL,
  ratio = 1,
  legend = NULL,
  colorbar = NULL,
  ...
)
}
\arguments{
\item{mtx}{A numeric \code{matrix} with named rows and columns.}

\item{colors}{A named \code{list()} with names matching \code{".grid"},
\code{colnames(top_tracks)}, and \code{colnames(left_tracks)}. Values
in this list should be a \bold{palette} definition (see section below).
Default: \code{"rocket"}.

For simple cases, a character vector can be given instead of a list. 
For example, \code{colors = "viridis"} is understood to mean the 
color palette name for the main grid, and 
\code{colors = c(Age = "magma", Male = "blue", Female = "red")}
will apply the magma palette to the Age metadata track, and blue and
red to the Sex metadata track. The default "rocket" palette will be 
used for the main grid unless otherwise defined.

To set a custom title in the color scale legend, provide a key 
prefixed by \code{.} like this:

\code{colors = list(.Abundance = list(palette = "rocket", name = "Grid Value")}.

To reverse the color order in a predefined palette, prepend a hyphen
to the name, for example \code{"-rocket"}.}

\item{top_tracks}{A \code{data.frame()} with row names matching 
\code{colnames(mtx)}. Each column will be its own track at the top
of the plot. Default: \code{NULL}.}

\item{left_tracks}{A \code{data.frame()} with row names matching 
\code{rownames(mtx)}. Each column will be its own track at the left
of the plot. Default: \code{NULL}.}

\item{label}{Label the matrix rows and columns. You can supply a list
or logical vector of length two to control row labels and column 
labels separately, for example 
\code{label = c(rows = TRUE, cols = FALSE)}, or simply 
\code{label = c(T, F)}. Other valid options are \code{"rows"},
\code{"cols"}, \code{"both"}, \code{"bottom"}, \code{"right"},
and \code{"none"}.
Default: \code{TRUE}.}

\item{label_size}{The font size to use for the row and column labels. You 
can supply a numeric vector of length two to control row label sizes 
and column label sizes separately, for example 
\code{c(rows = 20, cols = 8)}, or simply \code{c(20, 8)}.
Default: \code{NULL}, which computes: 
\code{pmax(8, pmin(20, 100 / dim(mtx)))}.}

\item{rescale}{Rescale rows or columns to all have a common min/max.
Options: \code{"rows"}, \code{"cols"}, or \code{NULL}.
Default: \code{NULL} (no rescaling).}

\item{trees}{Draw a dendrogram for rows (left) and columns (top). You can 
supply a list or logical vector of length two to control the row tree 
and column tree separately, for example 
\code{trees = c(rows = T, cols = F)}, or simply \code{trees = c(T, F)}. 
Other valid options are \code{"rows"}, \code{"cols"}, \code{"both"}, 
\code{"left"}, \code{"top"}, and \code{"none"}.
Default: \code{TRUE}.}

\item{clust}{Clustering algorithm for reordering the rows and columns by 
similarity. You can supply a list or character vector of length two to 
control the row and column clustering separately, for example 
\code{clust = c(rows = "complete", cols = NA)}, or simply 
\code{clust = c("complete", NA)}.
Default: \code{"complete"}.

Options are:
\itemize{
  \item{\code{FALSE} or \code{NA} - }{ Disable reordering. }
  \item{An \link[stats]{hclust} object} { }
  \item{An \link[stats]{hclust} method name - }{ \code{"ward.D"}, 
    \code{"ward.D2"}, \code{"single"}, \code{"complete"}, 
    \code{"average"}, \code{"mcquitty"}, \code{"median"}, or 
    \code{"centroid"}. }
}}

\item{dist}{Distance algorithm to use when reordering the rows and columns 
by similarity. You can supply a list or character vector of length
two to control the row and column clustering separately, for example 
\code{dist = c(rows = "euclidean", cols = "maximum")}, or simply 
\code{dist = c("euclidean", "maximum")}.
Default: \code{dist = "euclidean"}.

Options are:
\itemize{
  \item{A \link[stats]{dist} object} { }
  \item{A \link[stats]{dist} method name - }{ \code{"euclidean"}, 
    \code{"maximum"}, \code{"manhattan"}, \code{"canberra"}, 
    \code{"binary"}, or \code{"minkowski"}. }
}}

\item{tree_height, track_height}{The height of the dendrogram or annotation
tracks in multiples (or fractions) of the smaller dimension of the
grid cell size. Use a numeric vector of length two to assign
\code{c(left, top)} independently. Default: \code{NULL}, which computes:
\code{tree_height = sqrt(min(dim(mtx))), track_height = tree_height / 4}.}

\item{ratio}{Height/width ratio for entire grid.
Default: \code{1} (square).}

\item{legend}{Where to place the legend. Options are: \code{"right"} or
\code{"bottom"}. Default: \code{"right"}.}
}
\value{
A \code{ggplot2} plot. The constructed ggplot command will be
        attached as \code{attr(,'cmd')}, and the underlying computed data
        as \code{$data}.
}
\description{
Create a heatmap with tracks and dendrograms from any matrix.
}
\section{Palettes}{

         A palette can be as simple as the name of a color set, for example:
         
         \code{colors = "oranges"}
         
         You can use any name defined in the \code{paletteer} R package, 
         which aggregates color sets from a multitude of other R
         packages including \code{viridis}, \code{RColorBrewer}, and
         \code{ggpubr}, to name a few.
         
         Gradients from the \bold{viridis} and \bold{khroma} packages have
         good support for colorblindness:   \code{"viridis"}, \code{"magma"}, 
         \code{"plasma"}, \code{"inferno"}, \code{"cividis"}, \code{"mako"}, 
         \code{"rocket"}, \code{"turbo"},   \code{"broc"},    \code{"cork"},
         \code{"vik"},    \code{"lisbon"},  \code{"tofino"},  \code{"berlin"},
         \code{"roma"},   \code{"turku"},   \code{"vanimo"},  \code{"batlow"},
         \code{"devon"},  \code{"lajolla"}, \code{"bamako"},  \code{"davos"},
         \code{"bilbao"}, \code{"nuuk"},    \code{"oslo"},    \code{"grayC"},
         \code{"hawaii"}, \code{"lapaz"},   \code{"tokyo"},   \code{"buda"},
         \code{"acton"},  \code{"bam"},  or \code{"imola"}.
         
         To assign metadata track colors in addition to grid colors, combine
         them using a list. Any missing definitions will be auto-assigned.
         
         \code{colors = list("oranges", Sex = "wsj_red_green", 'Body Site' = "bugs")}
         
         You can also create custom color sets. For categorical data,
         provide a named character vector of color names. For continuous
         data, provide an unnamed character vector defining a gradient.
         
         \code{colors = list(Sex = list(palette = c('Male' = "blue", 'Female' = "#FF3390")))}
         
         \code{colors = list(Age = list(palette = c("azure", "darkblue", "darkorchid")))}
         
         You can also use this nested list structure to pass additional 
         parameters to the underlying ggplot2 \link[ggplot2]{discrete_scale} 
         or \link[ggplot2]{continuous_scale}, for example: 
         
         \code{colors = list(.grid = list(palette = "turbo", n.breaks = 5, 
         limits = c(0,1), reverse = TRUE, name = "Relative Abundance", 
         na.value = "grey50")}
         
         \itemize{
           \item{\code{name} - } { The title for this color scale in the legend. }
           \item{\code{na.value} - }{ The color to use for \code{NA} values. }
           \item{\code{limits} - }{ The c(min,max) to use for scale values. }
           \item{\code{n.breaks} - }{ Bin a gradient into this many bins/steps. }
           \item{\code{reverse} - }{ Reverse the order of colors. }
         }
}

\examples{
    library(rbiom)
    
    set.seed(123)
    mtx <- matrix(runif(5*8), nrow = 5)
    rownames(mtx) <- sample(LETTERS, nrow(mtx))
    colnames(mtx) <- sample(letters, ncol(mtx))
    
    plot_heatmap(mtx)
    plot_heatmap(mtx, colors="oranges")
    plot_heatmap(mtx, colors=list(palette = "oranges", name = "New Label", n.breaks = 5))
    
    top_tracks <- data.frame(
      row.names = colnames(mtx), 
      'Bool'    = sample(c(TRUE, FALSE), ncol(mtx), TRUE), 
      'Int'     = sample(1:20,           ncol(mtx), TRUE) )
    left_tracks <- data.frame(
      row.names = rownames(mtx),
      'City'    = sample(names(precip), nrow(mtx)) )
    plot_heatmap(mtx, top_tracks=top_tracks, left_tracks=left_tracks)
    
}
\seealso{
Other plotting: 
\code{\link{adiv_boxplot}()},
\code{\link{adiv_corrplot}()},
\code{\link{bdiv_biplot}()},
\code{\link{bdiv_boxplot}()},
\code{\link{bdiv_heatmap}()},
\code{\link{depths_barplot}()},
\code{\link{rare_corrplot}()},
\code{\link{rare_multiplot}()},
\code{\link{taxa_boxplot}()},
\code{\link{taxa_corrplot}()},
\code{\link{taxa_heatmap}()},
\code{\link{taxa_stacked}()}
}
\concept{plotting}
