---
title: "Benchmark"
author: "Daniel Smith, PhD"
date: "7/2/2018"
output: html_document
---

## Overview

Here we will compare rbiom to similar packages by measuring the time taken to complete common operations on a representative dataset.

## Create Test Environment

For our tests, we'll use a virtual machine on Amazon Web Service's Elastic Compute Cloud. Specifically:
* US-West region
* AMI 482e6430 ([QIIME 2 Core](https://s3-us-west-2.amazonaws.com/qiime2-data/distro/core/aws-amis.txt))
* c3.8xlarge instance type (32 virtual CPUs)
* 20 GiB General Purpose SSD (GP2) Storage on Root Volume

Both the username and password are 'qiime2'. On this instance, qiime2 is already configured. The following will download and install rbiom, phyloseq, and usearch as well as the test dataset.

```bash
sudo apt-get install build-essential gfortran libssl-dev unzip
export TAR=/bin/tar

R -e 'source("http://bioconductor.org/biocLite.R"); biocLite(c("phyloseq", "rhdf5"))'
R -e 'install.packages(c("devtools", "doParallel"), repos="http://cran.us.r-project.org");'
R -e 'devtools::install_git("https://github.com/cmmr/rbiom.git")'

wget https://s3.amazonaws.com/jplab/share/30d/usearch10.0.240
chmod a+x usearch10.0.240

wget https://raw.githubusercontent.com/cmmr/rbiom/master/vignettes/data/hmp500.biom

```


## Prepare input data

The example data is taken from the publicly available Human Microbiome Project. The master data set contains 4,468 samples with 4,468,000 observations of 1,140 OTUs. These samples have been rarefied to 1000 obervations per sample. The below script will randomly subset the master file to n samples, where n begins at 100 samples and is incremented by 100 all the way to 4,400. This will allow us to see how programs handle inputs of varying sizes.

prep_data.r:
```r
library(rbiom)

dir.create("in")
dir.create("out")
setwd("in")

x <- read.biom("https://s3.amazonaws.com/jplab/projects/hmp/hmp4468.biom")
for (i in 1:44) {
  n <- i * 100
  y <- select(x, sample.int(4468, n))
  y$taxonomy <- NULL
  write.biom(y, paste0("hmp", n, ".tab"), "tab")
  write.tree(y$phylogeny, paste0("hmp", n, ".tre"))
  cmd <- sprintf('biom convert -i hmp%i.tab -o hmp%i.json --table-type="OTU table" --to-json', n, n)
  system(command = cmd, wait = FALSE, ignore.stdout = TRUE, ignore.stderr = TRUE)
}
```

```bash
Rscript prep_data.r
```


## Weighted UniFrac

Create four scripts, one per program. These scripts will be the minimal steps needs to read in a biom file and newick, compute a distance matrix, then save the results to a tsv file. Each script will accept three arguments: (1) the number of cpu cores to use, (2) a single character 'w' or 'u' indicating whether to run weighted or unweighted unifrac, and (3) the infile size being tested, in number of samples.

```bash

cat > rbiom.r << EOF
args <- commandArgs(trailingOnly=TRUE)
options('rbiom.max.threads' = args[1])

bFile <- paste0("in/hmp", args[3],".json")
tFile <- paste0("in/hmp", args[3],".tre")
oFile <- paste0("out/rbiom_", args[2], "_dm", args[3],".tsv")

dm <- rbiom::unifrac(
  biom     = rbiom::read.biom(bFile),
  tree     = rbiom::read.tree(tFile), 
  weighted = identical(args[2], 'w') )
write.table(as.matrix(dm), oFile, sep="\t", quote=FALSE)
EOF


cat > phyloseq.r << EOF
library(methods)
args <- commandArgs(trailingOnly=TRUE)

if (args[1] > 1)
  doParallel::registerDoParallel(parallel::makePSOCKcluster(as.integer(args[1])))

bFile <- paste0("in/hmp", args[3],".json")
tFile <- paste0("in/hmp", args[3],".tre")
oFile <- paste0("out/phyloseq_", args[2], "_dm", args[3],".tsv")

dm <- phyloseq::UniFrac(
  phy        = phyloseq::import_biom(bFile, tFile), 
  weighted   = identical(args[2], 'w'), 
  parallel   = args[1] > 1, 
  normalized = FALSE )
write.table(as.matrix(dm), oFile, sep="\t", quote=FALSE)
EOF


cat > qiime2.sh << EOF
if [ \$2 = "u" ]; then metric="unweighted_unifrac"; else metric="weighted_unifrac"; fi
qiime tools import --input-path in/hmp\$3.json --output-path json --type FeatureTable[Frequency] --source-format BIOMV100Format
qiime tools import --input-path in/hmp\$3.tre --output-path tree --type Phylogeny[Rooted] --source-format NewickFormat
qiime diversity beta-phylogenetic-alt --i-table json.qza --i-phylogeny tree.qza --p-metric \$metric --output-dir qiime_out --p-n-jobs \$1
qiime tools export --output-dir qiime_out qiime_out/distance_matrix.qza
mv qiime_out/distance-matrix.tsv out/qiime2_\$2_dm\$3.tsv
rm -rf qiime_out
EOF


cat > usearch.sh << EOF
if [ \$2 = "u" ]; then metric="unifrac_binary"; else metric="unifrac"; fi
./usearch10.0.240 -beta_div in/hmp\$3.tab -metrics \$metric -tree in/hmp\$3.tre -quiet
mv \$metric.txt out/unifrac_\$2_dm\$3.tsv
rm \$metric.sorted.txt
rm \$metric.tree
EOF

```


Finally, execute and time each script.
```bash
/usr/bin/time -f 'Time: %E  Memory: %M\n' Rscript rbiom.r    8 u 500
/usr/bin/time -f 'Time: %E  Memory: %M\n' Rscript phyloseq.r 8 u 500
/usr/bin/time -f 'Time: %E  Memory: %M\n' /bin/sh qiime2.sh  8 u 500
/usr/bin/time -f 'Time: %E  Memory: %M\n' /bin/sh usearch.sh 8 u 500
```

Results using 8 cores and 500 samples:

| Package  | Time (MM:SS)  | Memory (kb) |
| -------- |:-------------:| -----------:|
| rbiom    | 0:03.56       |      109736 |
| qiime2   | 0:28.17       |      225896 |
| usearch  | 0:40.91       |        7140 |
| phyloseq | 1:59.55       |      445384 |

Results using 1 core and 4000 samples:

| Package  | Time (MM:SS)  | Memory (kb) |
| -------- |:-------------:| -----------:|
| rbiom    |  2:56.09      |      647860 |
| qiime2   |  3:10.19      |      513344 |
| usearch  | 31:53.29      |      128580 |


Results using 20 cores and 4000 samples:

| Package  | Time (MM:SS)  | Memory (kb) |
| -------- |:-------------:| -----------:|
| rbiom    |  2:56.09      |      647860 |
| qiime2   |  1:52.12      |     2008160 |
| phyloseq | 31:53.29      |      128580 |



Qiime2 says: `Weighted UniFrac is not parallelizable`
Weighted Output matrices: rbiom == phyloseq != UniFrac.
Unweighted Output matrices: rbiom == phyloseq == qiime2 != uniFrac.
And unifrac_binary also doesn't equal normalized unweighted phyloseq


Set these off in a loop
```bash

for i in {100..1000..100}
do
  /usr/bin/time -a -o results.txt -f "qiime2   1 w $i %e %M" /bin/sh qiime2.sh  1 w $i
  for j in {1..20}
  do
    /usr/bin/time -a -o results.txt -f "rbiom    $j w $i %e %M" Rscript rbiom.r    $j w $i
    /usr/bin/time -a -o results.txt -f "phyloseq $j w $i %e %M" Rscript phyloseq.r $j w $i
    /usr/bin/time -a -o results.txt -f "usearch  $j w $i %e %M" /bin/sh usearch.sh $j w $i
    /usr/bin/time -a -o results.txt -f "qiime2   $j u $i %e %M" /bin/sh qiime2.sh  $j u $i
    /usr/bin/time -a -o results.txt -f "rbiom    $j u $i %e %M" Rscript rbiom.r    $j u $i
    /usr/bin/time -a -o results.txt -f "phyloseq $j u $i %e %M" Rscript phyloseq.r $j u $i
    /usr/bin/time -a -o results.txt -f "usearch  $j u $i %e %M" /bin/sh usearch.sh $j u $i
  done
done

```






